def ctfi(displacement_per_min, sand_concentration_mass, sand_density, fluid_density, Z, D, R, u, dropoutrate, quantity,
         pdiameter, coeff2, detaTime=1):
    displacement_per_second = displacement_per_min / 60
    P_well_f = np.zeros(len(displacement_per_second))
    deta_Z = np.zeros(len(displacement_per_second))
    lamdas = []
    N_well_f2_list = []  # 用于收集每个时间步的 N_well_f2

    if isinstance(u, (int, float)):
        u = np.full(len(displacement_per_second), u)

    for t in range(len(displacement_per_second)):
        # 正常流动计算
        v = 4 * displacement_per_second[t] / (np.pi * D ** 2)
        # 确保黏度 u[t] 不为零（避免 Re_t 无穷大）
        u[t] = max(u[t], 1e-6)  # 最小黏度设为 1e-6 Pa·s
        Re_t = fluid_density * v * D / u[t]  # 修正：去掉多余的 *1000（单位已统一）

        # 1. 计算摩擦系数 f（区分层流/湍流）
        if Re_t < 2000:  # 层流（Re < 2000）
            f = 64 / Re_t  # 层流公式，无对数运算，避免 nan
        else:  # 湍流（Re >= 2000）
            # 计算原公式中的各项，保护对数参数为正数
            ratio_RD = R / D  # 粗糙度与直径比
            term_a = ratio_RD / 3.7
            term_b = 7.3 / Re_t
            log_arg1 = ratio_RD / 7 + term_b
            log_arg1 = max(log_arg1, 1e-6)  # 确保 log 参数为正
            term_c = 1.98 / Re_t * np.log(log_arg1)
            log_arg2 = term_a - term_c
            log_arg2 = max(log_arg2, 1e-6)  # 确保 log 参数为正
            # 计算湍流摩擦系数
            f = (1 / (-0.8686 * np.log(log_arg2))) ** 2

        # 2. 计算降阻率（已修复 np.clip 参数问题）
        dropoutrate = calculate_drag_reduction_rate(Re_t)
        drag_reduction = 1 - dropoutrate  # 确认物理意义：降阻率=1-阻力系数比

        # 3. 后续计算液柱段长度和密度（保持不变）
        deta_Z[t] = v * detaTime
        well_Z = []
        well_sand_concentration = []
        well_mix_midu = []

        if np.sum(deta_Z[:t + 1]) < Z:
            well_Z = list(deta_Z[:t + 1]) + [Z - np.sum(deta_Z[:t + 1])]
            well_sand_concentration = list(sand_concentration_mass[:t + 1]) + [0]
        else:
            sum_so_far = 0
            boundary = 0
            for i in range(t, -1, -1):
                sum_so_far += deta_Z[i]
                if sum_so_far > Z:
                    boundary = i
                    break
            well_Z = list(deta_Z[i] for i in range(t, boundary, -1)) + [
                Z - np.sum(deta_Z[i] for i in range(t, boundary, -1))]
            well_sand_concentration = list(sand_concentration_mass[i] for i in range(t, boundary, -1)) + [
                sand_concentration_mass[boundary]]

        well_Vp = np.array(well_sand_concentration) / sand_density
        well_mix_midu = (1 - well_Vp) * fluid_density + well_Vp * sand_density

        # 4. 计算井筒摩阻（避免 nan 传递）
        if len(well_mix_midu) > 0 and not np.isnan(f) and not np.isnan(v):
            friction_per_unit = (f / D * v ** 2) * np.array(well_mix_midu) / 2
            P_well_f[t] = np.sum(np.array(well_Z) * friction_per_unit) * drag_reduction
        else:
            P_well_f[t] = 0.0  # 异常时摩阻设为 0

    return P_well_f
