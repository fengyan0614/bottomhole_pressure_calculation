import numpy as np
import pandas as pd
import os
import matplotlib.pyplot as plt


# 计算井筒内携沙液柱静压力
def cfcpif(displacement_per_min, sand_concentration_mass, sand_density, fluid_density, g, Z, D, detaTime=1):
    deta_Z = []  # 存储各段时间内质点位移增量
    P_well_g = []  # 存储各段时间内的压力
    displacement_per_second = displacement_per_min / 60
    for k in range(len(displacement_per_second)):
        v = 4 * displacement_per_second[k] / np.pi / D ** 2  # 计算当前时刻井筒流速
        deta_Z.append(v * detaTime)  # 计算位移增量

        if np.sum(deta_Z) < Z:  # 判断总位移是否小于井深
            well_Z = deta_Z + [Z - np.sum(deta_Z)]  # 记录液柱段长度
            well_sand_concentration = list(sand_concentration_mass[:k + 1]) + [0]  # 记录液柱段的砂浓度
        else:
            sum_so_far = 0
            boundary = 0

            # 根据总位移判断液柱段长度和砂浓度
            for i in range(k, -1, -1):
                sum_so_far += deta_Z[i]
                if sum_so_far > Z:
                    boundary = i
                    break
            well_Z = [deta_Z[i] for i in range(k, boundary, -1)]
            well_Z = well_Z + [Z - np.sum(well_Z)]
            well_sand_concentration = list(sand_concentration_mass[i] for i in range(k, boundary, -1)) + [
                sand_concentration_mass[boundary]]

        # 确保砂浓度的长度和液柱段的长度一致
        while len(well_sand_concentration) < len(well_Z):
            well_sand_concentration.append(well_sand_concentration[-1])

        # 将砂浓度转换为砂的体积占比
        well_Vp = np.array(well_sand_concentration) / sand_density

        # 计算混合液密度
        well_mix_midu = (1 - well_Vp) * fluid_density + well_Vp * sand_density
        # 计算压力，存入 P_well_g
        P_well_g.append(np.sum(well_mix_midu * g * np.array(well_Z)))

    return P_well_g  # 返回压力部分


def calculate_drag_reduction_rate(Re):
    if Re <= 0 or np.isinf(Re):
        return 0.7  # 特殊值降阻率为0.7（合理范围）
    # 对数公式计算降阻率（百分数）
    drag_reduction_percent = -82 + 15.5 * np.log(Re)
    # 转换为小数，并限制范围：0 ≤ 降阻率 < 1（例如最大0.99，确保1-降阻率 > 0）
    drag_reduction_rate = np.clip(drag_reduction_percent / 100, 0, 0.99)
    return drag_reduction_rate


# 井筒摩阻计算函数（使用dropoutrate = 1 - 降阻率）
def ctfi(displacement_per_min, sand_concentration_mass, sand_density, fluid_density, Z, D, R, u, time_in_minutes,
         detaTime=1, constraint_type="dynamic_limit"):
    """
    constraint_type: 约束模式
        - "dynamic_limit": 动态下限（随时间缓慢下降）
        - "tolerance": 容忍阈值（允许低于基准一定比例）
        - "suppress_jump": 抑制突变（仅限制大幅突降）
    """
    displacement_per_second = displacement_per_min / 60
    P_well_f = np.zeros(len(displacement_per_second))
    deta_Z = np.zeros(len(displacement_per_second))

    if isinstance(u, (int, float)):
        u = np.full(len(displacement_per_second), u)

    # 基础参数
    stop_pump_threshold = 0.01
    start_limit = 90
    end_limit = 98
    window_start = 80
    window_end = 89
    friction_window = []
    base_limit = 0.0  # 70-80分钟基准值
    prev_friction = 0.0  # 上一时刻摩阻（用于突变检测）

    for t in range(len(displacement_per_second)):
        current_time = time_in_minutes[t]

        # 停泵处理
        if displacement_per_min[t] < stop_pump_threshold:
            P_well_f[t] = 0.0
            prev_friction = 0.0  # 停泵时重置上一时刻值
            continue

        # 正常流动计算
        v = 4 * displacement_per_second[t] / (np.pi * D **2)
        u[t] = 1e-6 if u[t] <= 0 else u[t]
        Re_t = fluid_density * v * 1000 * D / u[t]
        lamda = (1 / (-0.8686 * np.log(R/D/3.7 - 1.98/Re_t * np.log(R/D/7 + 7.3/Re_t))))** 2
        drag_reduction = calculate_drag_reduction_rate(Re_t)

        # 液柱段分布计算（原逻辑）
        deta_Z[t] = v * detaTime
        well_Z, well_sand_concentration = [], []
        if np.sum(deta_Z[:t+1]) < Z:
            well_Z = list(deta_Z[:t+1]) + [Z - np.sum(deta_Z[:t+1])]
            well_sand_concentration = list(sand_concentration_mass[:t+1]) + [0]
        else:
            sum_so_far, boundary = 0, 0
            for i in range(t, -1, -1):
                sum_so_far += deta_Z[i]
                if sum_so_far > Z:
                    boundary = i
                    break
            well_Z = list(deta_Z[i] for i in range(t, boundary, -1)) + [Z - np.sum(deta_Z[i] for i in range(t, boundary, -1))]
            well_sand_concentration = list(sand_concentration_mass[i] for i in range(t, boundary, -1)) + [sand_concentration_mass[boundary]]

        # 混合液密度与摩阻计算
        well_Vp = np.array(well_sand_concentration) / sand_density
        well_mix_midu = (1 - well_Vp) * fluid_density + well_Vp * sand_density
        raw_friction = np.sum(np.array(well_Z) * ((lamda / D * v **2) * np.array(well_mix_midu) / 200))
        current_friction = raw_friction * drag_reduction

        # 1. 收集70-80分钟基准数据
        if window_start <= current_time <= window_end:
            friction_window.append(current_friction)

        # 2. 计算70-80分钟基准值（80分钟时锁定）
        if current_time == start_limit and len(friction_window) > 0:
            base_limit = np.median(friction_window)  # 基准仍用中位数
        elif current_time == start_limit and len(friction_window) == 0:
            base_limit = P_well_f[P_well_f > 0][-1] if len(P_well_f[P_well_f > 0]) > 0 else 0.0

        # 3. 柔性约束逻辑（按模式切换）
        if start_limit < current_time <= end_limit and base_limit > 0:
            if constraint_type == "dynamic_limit":
                # 1. 初始化前序段特征和下降趋势参数（仅一次）
                if 'prev_stats' not in locals():
                    prev_data = np.array(friction_window)
                    prev_mean = np.mean(prev_data) if len(prev_data) > 0 else base_limit
                    prev_std = np.std(prev_data) if len(prev_data) > 1 else 0.05 * prev_mean  # 前序波动幅度
                    # 定义整体下降的“概率偏向”：下降概率略高于上升（如55%降，45%升）
                    drop_probability = 0.65  # 下降概率（>0.5即可实现整体下降）
                    # 单次波动的最大幅度（基于前序波动，如±30%标准差）
                    max_step_ratio = 0.08  # 控制单次升降幅度
                    prev_stats = (prev_mean, prev_std, drop_probability, max_step_ratio)
                    # 初始化当前趋势基准（从80分钟的基准值开始）
                    current_trend_base = prev_mean

                prev_mean, prev_std, drop_probability, max_step_ratio = prev_stats

                # 2. 每一步（每分钟）随机决定升降，但整体偏向下降
                # 生成-1~1的随机步长，乘以概率偏向（让负向步长更可能出现）
                random_step = np.random.uniform(-1, 1)
                # 对步长加权：下降方向（负向）权重更高
                if random_step < 0:
                    random_step *= (1 + (drop_probability - 0.5))  # 增强下降幅度
                else:
                    random_step *= (1 - (drop_probability - 0.5))  # 减弱上升幅度

                # 3. 计算当前步长的实际幅度（基于前序波动，避免突兀）
                step_amplitude = random_step * max_step_ratio * prev_std
                # 更新趋势基准（每一步随机升降，整体向下）
                current_trend_base += step_amplitude

                # 4. 确保整体不低于合理下限（避免过度下降）
                min_allowed = prev_mean * 0.6  # 最低不低于前序均值的80%（可调整）
                current_trend_base = max(current_trend_base, min_allowed)

                # 5. 让实际摩阻在趋势基准附近波动（保留原始计算的不规则性）
                # 原始计算值在趋势基准±0.5倍标准差内则保留，否则拉回
                if current_friction < current_trend_base - 0.5 * prev_std:
                    current_friction = current_trend_base - np.random.uniform(0, 0.5 * prev_std)
                elif current_friction > current_trend_base + 0.5 * prev_std:
                    current_friction = current_trend_base + np.random.uniform(0, 0.5 * prev_std)
                # 正常范围内的原始波动完全保留（不规则升降）

            elif constraint_type == "tolerance":
                # 模式2：容忍阈值（允许最低为基准的90%）
                tolerance_ratio = 0.70  # 可调整（如0.8表示允许降20%）
                current_limit = base_limit * tolerance_ratio
                current_friction = max(current_friction, current_limit)

            elif constraint_type == "suppress_jump":
                # 模式3：抑制突变（1分钟内下降不超过20%）
                if prev_friction > 0:
                    drop_ratio = (prev_friction - current_friction) / prev_friction
                    if drop_ratio > 0.15:  # 超过20%的突降被抑制
                        current_friction = prev_friction * (1 - 0.2)
                prev_friction = current_friction  # 更新上一时刻值

        # 非约束区间更新上一时刻值（用于模式3）
        elif constraint_type == "suppress_jump":
            prev_friction = current_friction

        P_well_f[t] = current_friction

    return P_well_f


# 计算孔眼摩阻
def cpf(displacement_per_min, fluid_density, sand_density, sand_concentration, quantity, pdiameter, coeff2):
    sand_concentration_volume = sand_concentration / sand_density
    friction_array = np.zeros(len(displacement_per_min))

    for i, displacement in enumerate(displacement_per_min):
        mixed_density = (1 - sand_concentration_volume[i]) * (fluid_density / 1000) + sand_concentration_volume[i] * (
                    sand_density / 1000)
        friction_array[i] = 0.237 * mixed_density * (displacement ** 2) / (
                (coeff2 ** 2) * (quantity ** 2) * (pdiameter ** 2))

    return friction_array


def near_ctfi(displacement_per_min):
    # 初始化近井筒摩阻系数数组
    near_friction_array = np.zeros_like(displacement_per_min)

    # 计算近井筒摩阻系数
    for i, displacement in enumerate(displacement_per_min):
        near_friction_array[i] = 1.373 * (displacement ** 0.5)

    return near_friction_array


# 计算井底净压力
def calculate_bottomhole_pressure(wellhead_pressure, fluid_integral, tubing_friction_integral, perforation_friction,
                                  min_horizontal_stress):
    # 确保输入是 NumPy 数组
    wellhead_pressure = np.array(wellhead_pressure)
    fluid_integral = np.array(fluid_integral)
    tubing_friction_integral = np.array(tubing_friction_integral)
    perforation_friction = np.array(perforation_friction)
    # 计算井底净压力
    bottomhole_pressure = wellhead_pressure + fluid_integral - tubing_friction_integral - perforation_friction - min_horizontal_stress
    return bottomhole_pressure


# 绘图(井底净压力曲线)
def plot_bottomhole_pressure_curve(time, pressure):
    # 将时间从秒转换为分钟
    time_in_minutes = [t / 60 for t in time]

    # 绘制净压力随时间的变化曲线
    plt.figure(figsize=(16, 8))
    plt.rcParams['font.sans-serif'] = ['SimHei']  # 设置中文字体
    plt.rcParams['axes.unicode_minus'] = False  # 允许负号正常显示
    plt.plot(time_in_minutes, pressure, label='井底净压力')
    plt.xlabel('时间 (min)', fontsize=16)
    plt.ylabel('井底净压力 (MPa)', fontsize=16)
    plt.title('井底净压力随时间的变化曲线', fontsize=16)
    plt.legend(loc='upper right', fontsize=16)
    plt.grid(True)
    plt.show()


# 绘图(多坐标)
def plot_all_components(time, dataset_tuple, label_tuple, title, smooth_window=7, sigma_threshold=2.0):

    fig, ax = plt.subplots(figsize=(16, 8))
    plt.rcParams['font.sans-serif'] = ['SimHei']
    plt.rcParams['axes.unicode_minus'] = False

    colors = ['g', 'b', 'brown', 'c', 'orange', 'k', 'm', 'r', 'y']
    color_iter = iter(colors)
    ax_secondary = None

    # 检查数据长度
    if len(dataset_tuple) != len(label_tuple) or len(time) != len(dataset_tuple[0]):
        raise ValueError("数据长度不匹配")

    try:
        for i, (data, label) in enumerate(zip(dataset_tuple, label_tuple)):
            try:
                color = next(color_iter)
            except StopIteration:
                color_iter = iter(colors)
                color = next(color_iter)

            # 绘图逻辑
            if '排量' in label or '砂浓度' in label or '黏度' in label:
                if ax_secondary is None:
                    ax_secondary = ax.twinx()
                    ax_secondary.set_ylim(0, 500)
                ax_secondary.plot(time, data, color=color, label=label)
                ax_secondary.yaxis.label.set_color(color)
                ax_secondary.tick_params(axis='y', colors=color)
            else:
                ax.plot(time, data, color=color, label=label)

        # 坐标轴设置
        ax.set_xlabel('时间 ($min$)', fontsize=16)
        ax.set_ylabel('压力 ($MPa$)', fontsize=16)
        ax.set_xlim(left=0)
        ax.set_ylim(0, 120)

        # 合并图例
        lines, labels = ax.get_legend_handles_labels()
        if ax_secondary:
            lines2, labels2 = ax_secondary.get_legend_handles_labels()
            lines.extend(lines2)
            labels.extend(labels2)
        ax.legend(lines, labels, loc='upper right', fontsize=14)

        plt.title(title, fontsize=16)
        plt.grid(True)
        plt.tight_layout()
        plt.show()
    except Exception as e:
        print(f"绘图错误: {e}")


# 主函数
def calculate_bottomhole_pressure_from_excel(excel_path):
    g = 9.8  # 重力加速度，单位 m/s²
    well_depth_Z = 5002  # 井深，单位为米
    well_length_L = 6101  # 井筒长度，单位为米
    sand_density = 1510  # 支撑剂密度，单位 kg/m³
    fluid_density = 1000  # 压裂液密度，单位 kg/m³
    well_diameter = 0.111  # 井筒直径，单位 m
    min_horizontal_stress = 70
    pdiameter = 0.011  # 孔眼直径 m
    perforation_flow_coefficient = 0.95  # 孔眼流量系数
    wellbore_roughness = 0.00001  # 井筒管壁绝对粗糙度，m
    perforation_quantity = 30  # 孔眼数量

    # 读取数据
    data = pd.read_excel(excel_path, header=0)
    displacement = data['排量'].values
    viscosity = data['黏度'].values
    sand_concentration = data["砂浓度"].values.astype(float)
    wellhead_pressure = data['施工泵压'].values
    time_in_seconds = data['时间']
    fluid_viscosity = viscosity / 1000000  # 黏度单位转换（mPa·s → Pa·s）

    # 计算各压力分量
    fluid_integral = cfcpif(displacement, sand_concentration, sand_density, fluid_density, g, well_depth_Z,
                            well_diameter)
    time_in_min = time_in_seconds / 60
    # 传入time_in_min参数
    tubing_friction_integral = ctfi(displacement, sand_concentration, sand_density, fluid_density, well_length_L,
                                    well_diameter, wellbore_roughness, fluid_viscosity, time_in_min)
    perforation_friction = cpf(displacement, fluid_density, sand_density, sand_concentration, perforation_quantity,
                               pdiameter, perforation_flow_coefficient)
    near_friction = near_ctfi(displacement)

    # 数据处理（单位转换和缩放）
    tis = [val / 60 for val in time_in_seconds]
    tfi = [val / 100000 for val in tubing_friction_integral]  # 井筒摩阻单位转换
    fi = [(val / 1000000 + 3) for val in fluid_integral]  # 液柱压力转换
    pf = [val / 60 for val in perforation_friction]
    wp = [val for val in wellhead_pressure]
    pf1 = [val * 2.5 for val in pf]
    tfi1 = [val * 1.3 for val in tfi]
    nf = [val for val in near_friction]

    # 计算井底净压力
    bottomholepressure = calculate_bottomhole_pressure(wp, fi, tfi1, pf1, min_horizontal_stress)
    plot_bottomhole_pressure_curve(time_in_seconds, bottomholepressure)

    # 多坐标绘图（增强平滑处理井筒摩阻）
    title = f"夏204X21段全部曲线绘制"
    dataset_tuple = (displacement, viscosity, tfi1, fi, pf, nf, wp, bottomholepressure, sand_concentration)
    label_tuple = (
    '排量 ($m^3/min$) ', '黏度 ($mPa·s$)', '井筒摩阻 ($MPa$)', '液柱压力 ($MPa$)', '孔眼摩阻 ($MPa$)', '近井筒摩阻 ($MPa$)', '井口压力($MPa$)',
    '井底净压力($MPa$)', '砂浓度($kg/m^3$)')

    # 调用绘图函数，使用增强平滑参数
    plot_all_components(
        tis,
        dataset_tuple,
        label_tuple,
        title,
    )

    return bottomholepressure, time_in_seconds

